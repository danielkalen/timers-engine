// Generated by CoffeeScript 1.10.0
(function() {
  (function() {
    var Timer;
    Timer = new function() {
      this.timers = {};
      this.callbacks = {};
      this.timePassed = {};
      this.add = function(arg) {
        var interval, label, startTime, stopAfter, updateCallback;
        label = arg.label, interval = arg.interval, stopAfter = arg.stopAfter, updateCallback = arg.updateCallback;
        this.timePassed[label] = 0;
        this.callbacks[label] = {};
        startTime = Date.now();
        this.timers[label] = setInterval((function(_this) {
          return function() {
            if (typeof updateCallback === "function") {
              updateCallback();
            }
            _this.timePassed[label] = Date.now() - startTime;
            return _this.invokeCallbacks(label, _this.timePassed[label]);
          };
        })(this), interval);
        if (stopAfter) {
          return setTimeout((function(_this) {
            return function() {
              return _this.remove(label);
            };
          })(this), stopAfter);
        }
      };
      this.remove = function(label) {
        clearInterval(this.timers[label]);
        delete this.timers[label];
        delete this.callbacks[label];
        return delete this.timePassed[label];
      };
      this.listen = function(label, targetTime, callbackToInvoke) {
        var base;
        if (!this.callbacks[label]) {
          return console.error("Failed to listen to a timer - '" + label + "' doesn't exist.");
        } else {
          if ((base = this.callbacks[label])[targetTime] == null) {
            base[targetTime] = [];
          }
          return this.callbacks[label][targetTime].push(callbackToInvoke);
        }
      };
      this.invokeCallbacks = function(label, timePassed) {
        var callback, exceededTimePoints, i, j, len, len1, ref, results, timePoint;
        if (this.callbacks[label]) {
          exceededTimePoints = Object.keys(this.callbacks[label]).filter(function(timePoint) {
            return parseFloat(timePoint) < timePassed;
          });
          if (exceededTimePoints.length) {
            results = [];
            for (i = 0, len = exceededTimePoints.length; i < len; i++) {
              timePoint = exceededTimePoints[i];
              ref = this.callbacks[label][timePoint];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                callback = ref[j];
                callback();
              }
              results.push(delete this.callbacks[label][timePoint]);
            }
            return results;
          }
        }
      };
      return this;
    };
    return window.Timer = Timer;
  })();

}).call(this);
